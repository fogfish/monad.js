<!DOCTYPE html>
<!--
//
// Copyright (C) 2016 Dmitry Kolesnikov
//
// This software may be modified and distributed under the terms
// of the MIT license.  See the LICENSE file for details.
//
-->

<!-- 

The uses SAM technique developed at (see links below) as baseline for 
pure functional design of front-end components
http://www.infoq.com/articles/no-more-mvc-frameworks
http://jdubray.github.io/sam/


The challenge of MVC-based frameworks is a poorly designed API which 
induces the programmer to mix multiple concerns in one component. 

Let's build a web app with no MVC framework whatsoever, using just plain 
old JavaScript function. The author of these documents has developed a pattern 
State-Action-Model to facilitate reactive development

   V = S( vm( M.present( A(data) ) ), nap(M))

This patterns define a computation flow using a pure side-effect free functions.
The action (A: event -> data) computes data from various events. The data is
present to the model (M.present: data -> model) and triggers necessary update
actions. The view is rendered using model state (S: model -> view).

We can declare a minimal contract between model and view, the pure functional view
allow us adapt the model as required by view. 

There is a weak points here
* the next-action predicate (nap) is defined as callback to invoke continuation. 
* there are not strict abstraction on the functional composition 
  (e.g. author examples fall-back to traditional callback approach)
* the model is responsible for its persistence but its functional abstraction is omitted.

We can observe that Action(s) is only pure as event mapper but event generator is 
a function with side-effect. Thus, this is IO-monad. SAM patterns is monadic computation
```
do
   data   <- A
   model  <- M.present(data)
   view   <- S( vm(model) )
   action <- nap(model) 
```

Let's use controls a rocket launcher example to demonstrate the usage of monad's in reactive 
development. The application model and its state-machine is derived from original posts.

-->


<script src="http://d3js.org/d3.v3.min.js"></script>
<script src="http://gsf.github.io/whiskers.js/whiskers.min.js"></script>
<script src="../src/monad.js"></script>

<style type="text/css">
.red{color: red;}
.green{color: green;}
.black{color: black;}
</style>

<body>
<button id="launch">Launch</button> <button id="abort">Abort</button>
<div></div>

<script type="text/javascript">

var COUNTER_MAX = 10;
var COUNTER_MIN = 0;

//
// application model is singleton
var model = {
   counter: COUNTER_MAX, 
   started: false,      
   launched: false, 
   aborted: false
};


//-----------------------------------------------------------------------------
//
// side-effect actions
//
//----------------------------------------------------------------------------- 
var action = (function()
{
   var self = {};

   //
   // action decrement clock value once timeout exhausted, 
   // the new timer value is proposed to acceptor 
   self.decrement = function(t, timeout, acceptor)
   {
      d3.timer(
         function()
         {
            acceptor(t - 1); 
            return true;
         }, 
         timeout
      );
   }.curry();

   //
   // the launch action proposed max counter value on user action
   self.launch = function(acceptor)
   {
      d3.select('#launch').on('click', 
         function(_)
         {
            acceptor(COUNTER_MAX)
         }
      ); 
   }.curry();

   //
   // the cancel action aborts the procedure
   self.cancel = function(acceptor)
   {
      d3.select('#abort').on('click',
         function(_)
         {
            acceptor(COUNTER_MIN)
         }
      )
   }.curry();

   return self;   
})();


//-----------------------------------------------------------------------------
//
// model presenter
//
//-----------------------------------------------------------------------------
var presenter = (function()
{
   var self = {};

   //
   //
   self.counting = function(model, t)
   {
      if (!model.aborted)
      {
         model.counter  = t;
         model.started  = t  > 0 ? true : false;
         model.launched = t == 0 ? true : false;
      }
      return model;
   }.curry();

   //
   //
   self.aborted = function(model, t)
   {
      if ((!model.launched) && (t === COUNTER_MIN))
      {
         model.started  = false;
         model.launched = false; 
         model.aborted  = true;
      }
      return model;
   }.curry();

   return self;
})();


//-----------------------------------------------------------------------------
//
// state
//
//-----------------------------------------------------------------------------
var state = (function()
{
   var self = {};
   
   //
   //
   var vm = function(model)
   {
      var color = model.aborted ? "red" : (model.launched ? "green" : "black");
      return {t: "" + model.counter, color: color};
   }

   //
   //
   self.display = function(ui, model)
   {
      d3.select('div').html( ui(vm(model)) );
      return model
   }.curry();

   return self;
})();


//-----------------------------------------------------------------------------
//
// view
//
//-----------------------------------------------------------------------------
var view = (function()
{
   var self = {};

   //
   //
   self.counter = whiskers.compile('<p>Count down: <strong class="{color}">{t}</strong></p>');

   return self;
})();

//-----------------------------------------------------------------------------
//
// next-action predicate
//
//-----------------------------------------------------------------------------
var nap = (function()
{
   var self = {};

   //
   //
   self.continuation = function(model)
   {
      if ((model.counter > 0) && (!model.aborted))
         computation.tick(model.counter);
      return model;
   }.curry();

   return self;
})();


//-----------------------------------------------------------------------------
//
// re-usable computation(s) 
//
//-----------------------------------------------------------------------------
var computation = (function()
{
   var self  = {};

   self.tick = function(t)
   {
      monad.do([
         monad.IO(action.decrement(t, 1000)),
         presenter.counting(model),
         state.display(view.counter),
         nap.continuation
      ])
   }

   return self;
})();

//-----------------------------------------------------------------------------
//
// entry point
//
//-----------------------------------------------------------------------------


//
//
monad.do([
   monad.UI(action.launch),
   presenter.counting(model),
   state.display(view.counter),
   nap.continuation
]);


//
//
monad.do([
   monad.UI(action.cancel),
   presenter.aborted(model),
   state.display(view.counter)
])

//
//
monad.do([
   monad.IO(COUNTER_MAX),
   presenter.counting(model),
   state.display(view.counter)
]);

</script>
</body>
